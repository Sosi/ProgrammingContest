CodeChef October Challenge, POST
来源： 吴垠的日志
好久没写解题报告了。其实我已经不太想写解题报告了，但是由于这道题实在是太BT了，所以觉得不写实在是遗憾。

虽然这道题很BT，可是题目描述却不是一般的简单，很难让人往复杂了想。有一个(W+1)*(H+1)的格点地图，每个点只和它上下左右四个点相连（边界除外）。现在想从(0, 0)点走到(W, H)点，但是其中有N个点变成了障碍不能走。现在问，如果遵循最短路径走的话，总共有多少条不同的最短路，或者根本没有路径。把结果模上一个固定的常数就好。其中W, H <= 10^7，N <= max(100, min(W, H, 1000))。

这个题里N的约束条件非常诡异，但是一时间又想不出什么。其实这道题还真就是因为N的这个约束条件，所以我才会做，要是约束直接写成N <= 1000，我就彻底不会了。让我们一步一步分析。

先从最简单的情况下入手。我们会想到，如果W和H比较小的话，那么就可以使用各种暴力的方法去做了，所以我们先从最“难”的情况入手，也就是如果W和H都非常非常大（我们先不去考虑这个界到底是多少），这个时候怎么办？直观感觉可以猜到，如果W和H都非常大的话，由于有很大的空地，那些稀疏的障碍是很难挡到什么东西的，我们绝大部分的时间都只需要往下或者右走，偶尔避开障碍就好了。所以可以预想到，我们可能首先需要解决这么一个问题，那就是从(0, 0)到(W, H)，每次只能走下或者右，有多少种走法？很容易可以想到容斥原理，这个直接做的复杂度虽然是O(2^n)的，不过稍微观察下就能发现一种用DP的O(n^2)实现。这个小问题是解决了，不过当W和H非常大的时候，一定会走最短路么？显然不一定，因为很明显，只要把很多的点集中在起点或者终点附近 ，就很轻易的可以构造出一个迂回曲折的迷宫来，使得这个“每次只能向下或者向右”的假设被瞬间打破。但是我们会发现，当迂回到一定程度的时候，由于点数太少，地方越来越空旷，这个时候才会一直向下或者向右走。所以我们可以对起末点周围的范围做一个暴力最短路径，算出一些中间点来，然后从这些点开始就会一直朝着目标前进。不过这个范围是多少呢？可以发现，如果这个地图中至少有一行和一列是空的，那么我们只要达到这个点，就可以四通八达，顺着这些空行列直接到达目标。而起末点开始第一个空行/列的下标不会超过N。所以这个时候，我们只需要预处理出起末点周围第一个空行列的位置，然后对这个范围内的点进行O(N^2)的暴力计算，之后对这些点用容斥原理做就好了。这边还有一个小问题：预处理出的这些“中间点”，不一定都是最短路上的一个点。但是哪些是呢？我们发现，其实每个点到底会对路径长度有多大的影响，实际上取决于到达这个点的时候，究竟走了多少次上和左。只要这个次数确定，那么路径长度就一定是确定的。所以想要路径长度最短，就一定要选择那些 走了上和左次数最少的那些点，也就是“耗费”最少。剩下的都不能要。而起末点之间的任何两个中间点都是可以配对的，因为他们的耗费都是一样的。于是在W和H都很大的时候，我们可以用这个O(N^2)的算法去解决问题。

所以现在的问题就是，如果两行中有某一行（或某一列，一样的。下面默认是行）全都布满了点呢？很明显，这样的话行数一定不会很大，也就是不大于1000。如果此时列数也很少的话，那整个地图就是很小的了，我们直接用各种暴力算法就可以解。所以问题就是列很大的时候该怎么办。当列很大的时候，一定是存在空列的，而对空列我们不用对其进行暴力枚举，因为可以直接用C(n, k)来计算任何两点间路径的条数。所以此时可以设计出一个O(NW^2)的算法，也就是说，记录一下前X列走完，最后达到(W_i, X)这个点时的最短路径及其不同方法数，把这W+1行每行的值都算出来。然后判断它前方究竟是空地还是有障碍。如果有障碍，那么利用这个信息，在这一小块障碍内进行暴力计算来穿越它，由于这个小范围里每一列都有障碍，所以整个过程全部加起来也就是O(N^2)的大小；如果无障碍，那么在这一大块空地里，我们必然是要用直走的方式来前进的，这时对这大块的空地，只要枚举起末点（起点在最左侧，终点在最右侧），计算路径长度和方法数进行更新就好了。每次更新需要O(W^2)的时间，而障碍块的数目最多有n块，所以总的复杂度是O(NW^2)的。

但是上面那个算法在W很大的时候显然是不能用的，所以当W很大的时候，我们必须要想别的方法。这是请注意到n的约束范围：n <= max(100, min(W, H, 1000))。我们会发现，当W <= 100的时候，上面的那个算法可以成功使用。而当W > 100的时候，n约束条件右面那个式子的值居然正好是W（在这里我们假设H是足够大的，因为如果H不大的话，可以使用直接暴力来计算）。如果严密推导的话，就是当W > 100时，N <= max(100, min(W, H, 1000)) <= max(100, W) = W。而当N <= W使时，由于有W+1行，一定有一行是空的，这样就不符合我们考虑的“所有的行都是满的”这个条件，这个问题就可以用我们一开始所讲的容斥原理来做了。

PS: 其实这道题我一开始想复杂了，因为我误以为当W很大的时候（也就是100 <= W <= 1000）也有可能每行都布满了节点，所以另外解决了一种新的情况，再写这个报告的时候才发现的这个问题。下面提出的问题就包含了那个题目中不会发生的情况：如果我把这个约束条件变一下，变成N <= max(100, min(W, H, 1000)+1)，那么该怎么做呢？